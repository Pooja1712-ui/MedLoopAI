const BlogPost = require("../models/BlogPost.model");
const User = require("../models/User.model"); // Needed to associate author
const { validationResult } = require("express-validator");
const slugify = require("slugify"); // For potential slug checks if needed later

// @desc    Create a new blog post
// @route   POST /api/blogs
// @access  Private/Admin
exports.createBlogPost = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { title, content, status, featuredImage, tags } = req.body;

  try {
    // req.user.id comes from the 'protect' middleware
    const author = req.user.id;

    // Slug will be auto-generated by Mongoose middleware
    const newPost = new BlogPost({
      title,
      content,
      author,
      status: status || "draft", // Default to draft if not provided
      featuredImage,
      tags,
    });

    const post = await newPost.save();

    // Populate author details before sending response
    await post.populate("author", "fullName email"); // Select fields to return

    res.status(201).json(post);
  } catch (error) {
    console.error("Error creating blog post:", error.message);
    // Handle potential duplicate slug error (though unlikely on create if title is unique enough)
    if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
      return res
        .status(400)
        .json({
          msg: "A post with a similar title already exists, resulting in a duplicate slug.",
        });
    }
    res.status(500).send("Server Error");
  }
};

// @desc    Get all blog posts (optionally filter by status)
// @route   GET /api/blogs
// @access  Public (published) / Private/Admin (all)
exports.getAllBlogPosts = async (req, res) => {
  try {
    let query = {};

    // If the user is NOT an admin, only show published posts
    // Check if req.user exists (from protect middleware, optional here) and their role
    const isAdmin = req.user && req.user.role === "admin";
    if (!isAdmin) {
      query.status = "published";
    }

    // Add filter by status if provided in query params (e.g., /api/blogs?status=draft)
    if (req.query.status && isAdmin) {
      // Only admins can filter by status explicitly
      if (["draft", "published"].includes(req.query.status)) {
        query.status = req.query.status;
      }
    }

    // Sort by newest first, populate author name/email
    const posts = await BlogPost.find(query)
      .populate("author", "fullName email")
      .sort({ createdAt: -1 });

    res.json(posts);
  } catch (error) {
    console.error("Error fetching blog posts:", error.message);
    res.status(500).send("Server Error");
  }
};

// @desc    Get a single blog post by slug
// @route   GET /api/blogs/:slug
// @access  Public (if published) / Private/Admin (if draft)
exports.getBlogPostBySlug = async (req, res) => {
  try {
    const post = await BlogPost.findOne({ slug: req.params.slug }).populate(
      "author",
      "fullName email"
    );

    if (!post) {
      return res.status(404).json({ msg: "Blog post not found" });
    }

    // Check if the post is a draft and the user is not an admin
    const isAdmin = req.user && req.user.role === "admin";
    if (post.status === "draft" && !isAdmin) {
      return res
        .status(403)
        .json({ msg: "Not authorized to view this draft post" });
    }

    res.json(post);
  } catch (error) {
    console.error("Error fetching single blog post:", error.message);
    res.status(500).send("Server Error");
  }
};

// @desc    Update a blog post by ID
// @route   PUT /api/blogs/:id
// @access  Private/Admin
exports.updateBlogPost = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { title, content, status, featuredImage, tags } = req.body;
  const updateFields = {};
  if (title !== undefined) updateFields.title = title;
  if (content !== undefined) updateFields.content = content;
  if (status !== undefined) updateFields.status = status;
  if (featuredImage !== undefined) updateFields.featuredImage = featuredImage;
  if (tags !== undefined) updateFields.tags = tags;

  // Slug will be updated via Mongoose middleware if title changes

  try {
    let post = await BlogPost.findById(req.params.id);

    if (!post) {
      return res.status(404).json({ msg: "Blog post not found" });
    }

    // Optional: Check if the logged-in user is the author or admin
    // if (post.author.toString() !== req.user.id && req.user.role !== 'admin') {
    //    return res.status(401).json({ msg: 'User not authorized' });
    // }

    post = await BlogPost.findByIdAndUpdate(
      req.params.id,
      { $set: updateFields },
      { new: true, runValidators: true } // Return the updated doc, run schema validators
    ).populate("author", "fullName email");

    res.json(post);
  } catch (error) {
    console.error("Error updating blog post:", error.message);
    if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
      return res
        .status(400)
        .json({
          msg: "Update failed: A post with a similar title already exists, resulting in a duplicate slug.",
        });
    }
    res.status(500).send("Server Error");
  }
};

// @desc    Delete a blog post by ID
// @route   DELETE /api/blogs/:id
// @access  Private/Admin
exports.deleteBlogPost = async (req, res) => {
  try {
    const post = await BlogPost.findById(req.params.id);

    if (!post) {
      return res.status(404).json({ msg: "Blog post not found" });
    }

    // Optional: Check if the logged-in user is the author or admin
    // if (post.author.toString() !== req.user.id && req.user.role !== 'admin') {
    //    return res.status(401).json({ msg: 'User not authorized' });
    // }

    // Mongoose 6+ uses deleteOne() or findByIdAndDelete()
    await BlogPost.findByIdAndDelete(req.params.id);

    res.json({ msg: "Blog post removed" });
  } catch (error) {
    console.error("Error deleting blog post:", error.message);
    // Handle CastError if ID format is invalid
    if (error.kind === "ObjectId") {
      return res.status(404).json({ msg: "Blog post not found with that ID" });
    }
    res.status(500).send("Server Error");
  }
};
